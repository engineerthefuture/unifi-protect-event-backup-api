
# CloudFormation template for static website hosting with S3, CloudFront, Route53, ACM, and Cognito for the Unifi Protect Event Backup API UI.
AWSTemplateFormatVersion: "2010-09-09"
Description: CloudFormation stack for static website hosting with S3 and CloudFront for the Unifi Protect Event Backup API UI.

# Stack-level tags
Metadata:
  AWS::CloudFormation::Interface:
    Tags:
      - Key: Owner
        Value: !Ref OwnerName
      - Key: Description
        Value: !Ref AppDescription
      - Key: Environment
        Value: !Ref EnvPrefix
      - Key: AppName
        Value: !Ref AppName
      - Key: SupportEmail
        Value: !Ref SupportEmail

############################################################
# Parameters: Customize stack for different environments   #
############################################################

############################################################
# Parameters: Customize stack for different environments   #
############################################################
Parameters:
  EnvPrefix:
    Type: String
    Description: Prefix for the environment (dev, prod, staging)
    Default: dev
  AppName:
    Type: String
    Description: Name of the application
    Default: ""
  BucketName:
    Type: String
    Description: S3 bucket name for the static website
    Default: ""
  DomainName:
    Type: String
    Description: Custom domain name for the static site (e.g., site.brentfoster.me)
    Default: ""
  HostedZoneId:
    Type: String
    Description: Route53 Hosted Zone ID for the domain
    Default: ""

############################################################
# Conditions: Used for optional resources (e.g. custom domain)
############################################################
Conditions:
  HasCustomDomain: !Not [!Equals [!Ref DomainName, ""]]
  HasHostedZone: !Not [!Equals [!Ref HostedZoneId, ""]]
  UseCustomDomain: !And [!Condition HasCustomDomain, !Condition HasHostedZone]



############################################################
# Resources: Main infrastructure components                #
############################################################
Resources:

  # Lambda@Edge function for JWT authorization using Cognito
  AuthorizationLambdaEdge:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "bf-${EnvPrefix}-${AppName}-auth-lambda-edge"
      Handler: index.handler
      Role: !GetAtt AuthorizationLambdaEdgeRole.Arn
      Runtime: nodejs18.x
      Description: Lambda@Edge function to authorize CloudFront requests using Cognito JWT
      MemorySize: 128
      Timeout: 5
      Code:
        ZipFile: |
          'use strict';
          var jwt = require("jsonwebtoken");
          var jwkToPem = require("jwk-to-pem");
          var USERPOOLID = "##USERPOOLID##";
          var JWKS = '##JWKS##';
          var region = 'us-east-1';
          var iss = 'https://cognito-idp.' + region + '.amazonaws.com/' + USERPOOLID;
          var pems = {};
          var keys = JSON.parse(JWKS).keys;
          for(var i = 0; i < keys.length; i++) {
              var key_id = keys[i].kid;
              var modulus = keys[i].n;
              var exponent = keys[i].e;
              var key_type = keys[i].kty;
              var jwk = { kty: key_type, n: modulus, e: exponent};
              var pem = jwkToPem(jwk);
              pems[key_id] = pem;
          }
          const response401 = { status: '401', statusDescription: 'Unauthorized' };
          exports.handler = (event, context, callback) => {
              const cfrequest = event.Records[0].cf.request;
              const headers = cfrequest.headers;
              if(!headers.authorization) { callback(null, response401); return false; }
              var jwtToken = headers.authorization[0].value.slice(7);
              var decodedJwt = jwt.decode(jwtToken, {complete: true});
              if (!decodedJwt) { callback(null, response401); return false; }
              if (decodedJwt.payload.iss != iss) { callback(null, response401); return false; }
              if (decodedJwt.payload.token_use != 'access') { callback(null, response401); return false; }
              var kid = decodedJwt.header.kid;
              var pem = pems[kid];
              if (!pem) { callback(null, response401); return false; }
              jwt.verify(jwtToken, pem, { issuer: iss }, function(err, payload) {
                if(err) { callback(null, response401); return false; }
                else { delete cfrequest.headers.authorization; callback(null, cfrequest); return true; }
              });
          };

  # Lambda@Edge execution role
  AuthorizationLambdaEdgeRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
                - edgelambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: LambdaEdgeBasic
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"

  # Cognito User Pool for authentication (email sign-up/sign-in)
  CognitoUserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: !Sub "bf-${EnvPrefix}-${AppName}-userpool"
      AutoVerifiedAttributes:
        - email
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireUppercase: true
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: false
      Schema:
        - Name: email
          Required: true
          Mutable: true

  # Cognito User Pool Client for web app authentication
  CognitoUserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      ClientName: !Sub "bf-${EnvPrefix}-${AppName}-client"
      UserPoolId: !Ref CognitoUserPool
      GenerateSecret: false
      ExplicitAuthFlows:
        - ALLOW_USER_PASSWORD_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH
        - ALLOW_USER_SRP_AUTH
        - ALLOW_CUSTOM_AUTH
      SupportedIdentityProviders:
        - COGNITO

  # ACM Certificate for custom domain (DNS validated)
  Certificate:
    Type: AWS::CertificateManager::Certificate
    Condition: UseCustomDomain
    Properties:
      DomainName: !Ref DomainName
      ValidationMethod: DNS
      DomainValidationOptions:
        - DomainName: !Ref DomainName
          HostedZoneId: !Ref HostedZoneId
      Tags:
        - Key: "Name"
          Value: !Sub "bf-${EnvPrefix}-${AppName}-cert"

  # S3 bucket for static website hosting (private, accessed via CloudFront)
  WebsiteBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref BucketName
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      WebsiteConfiguration:
        IndexDocument: index.html
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders:
              - '*'
            AllowedMethods:
              - GET
            AllowedOrigins:
              - '*'
            Id: OpenCors
            MaxAge: '3600'
      Tags:
        - Key: "Name"
          Value: !Sub "bf-${EnvPrefix}-${AppName}-ui"

  # CloudFront Origin Access Identity to restrict S3 access to CloudFront only
  CloudFrontOriginIdentity:
    Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: !Sub "bf-${EnvPrefix}-origin-identity"

  # S3 Bucket Policy to allow CloudFront OAI to read from the website bucket
  WebUIPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref WebsiteBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              CanonicalUser: !GetAtt CloudFrontOriginIdentity.S3CanonicalUserId
            Action: "s3:GetObject"
            Resource: !Sub "${WebsiteBucket.Arn}/*"

  # CloudFront Distribution for the static website (with custom error responses for SPA routing)
  WebsiteCloudFront:
    Type: AWS::CloudFront::Distribution
    DependsOn:
      - WebsiteBucket
    Properties:
      DistributionConfig:
        Origins:
          - DomainName: !GetAtt WebsiteBucket.RegionalDomainName
            Id: !Ref WebsiteBucket
            S3OriginConfig:
              OriginAccessIdentity: !Sub "origin-access-identity/cloudfront/${CloudFrontOriginIdentity}"
            OriginCustomHeaders:
              - HeaderName: Access-Control-Allow-Origin
                HeaderValue: '*'
        Enabled: true
        Comment: !Sub "bf-${EnvPrefix} - ${AppName}"
        Aliases: !If [UseCustomDomain, [!Ref DomainName], []]
        DefaultRootObject: index.html
        # Add a behavior for private/* that uses Lambda@Edge for authorization
        CacheBehaviors:
          - PathPattern: private/*
            TargetOriginId: !Ref WebsiteBucket
            ViewerProtocolPolicy: redirect-to-https
            AllowedMethods:
              - GET
              - HEAD
              - OPTIONS
            CachedMethods:
              - GET
              - HEAD
            Compress: false
            ForwardedValues:
              QueryString: true
              Cookies:
                Forward: none
              Headers:
                - Authorization
            LambdaFunctionAssociations:
              - EventType: viewer-request
                LambdaFunctionARN: !GetAtt AuthorizationLambdaEdge.Version
        DefaultCacheBehavior:
          TargetOriginId: !Ref WebsiteBucket
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods:
            - HEAD
            - DELETE
            - POST
            - GET
            - OPTIONS
            - PUT
            - PATCH
          CachedMethods:
            - GET
            - HEAD
            - OPTIONS
          Compress: false
          ForwardedValues:
            QueryString: true
            Cookies:
              Forward: none
            Headers:
              - Access-Control-Request-Headers
              - Access-Control-Request-Method
              - Origin
        PriceClass: PriceClass_100
        Restrictions:
          GeoRestriction:
            RestrictionType: whitelist
            Locations:
              - US
              - CA
        ViewerCertificate: !If
          - UseCustomDomain
          - {
              AcmCertificateArn: !Ref Certificate,
              MinimumProtocolVersion: TLSv1.2_2021,
              SslSupportMethod: sni-only
            }
          - { CloudFrontDefaultCertificate: true }
        CustomErrorResponses:
          - ErrorCode: 404
            ResponseCode: 200
            ResponsePagePath: /index.html
          - ErrorCode: 403
            ResponseCode: 200
            ResponsePagePath: /index.html
      Tags:
        - Key: "Name"
          Value: !Sub "bf-${EnvPrefix}-ui-cdn"

  # Route53 A record for custom domain pointing to CloudFront
  CloudFrontAliasRecordA:
    Type: AWS::Route53::RecordSet
    Condition: UseCustomDomain
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Ref DomainName
      Type: A
      AliasTarget:
        DNSName: !GetAtt WebsiteCloudFront.DomainName
        HostedZoneId: Z2FDTNDATAQYW2

  # Route53 AAAA record for custom domain pointing to CloudFront (IPv6)
  CloudFrontAliasRecordAAAA:
    Type: AWS::Route53::RecordSet
    Condition: UseCustomDomain
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Ref DomainName
      Type: AAAA
      AliasTarget:
        DNSName: !GetAtt WebsiteCloudFront.DomainName
        HostedZoneId: Z2FDTNDATAQYW2


############################################################
# Outputs: Useful values after stack creation               #
############################################################
Outputs:
  # S3 static website endpoint (not used directly, for reference)
  S3WebsiteURL:
    Value: !GetAtt WebsiteBucket.WebsiteURL
  # CloudFront distribution domain name
  CloudFrontDomain:
    Value: !GetAtt WebsiteCloudFront.DomainName
  # CloudFront distribution ID
  CloudFrontDistributionId:
    Description: "CloudFront Distribution ID"
    Value: !Ref WebsiteCloudFront

  # Cognito User Pool ID for use in UI app config
  CognitoUserPoolId:
    Description: "Cognito User Pool ID"
    Value: !Ref CognitoUserPool

  # Cognito User Pool Client ID for use in UI app config
  CognitoUserPoolClientId:
    Description: "Cognito User Pool Client ID"
    Value: !Ref CognitoUserPoolClient
